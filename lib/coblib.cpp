/*Generated from coblib.asm*/
add_asm(";AUXILIAR SECTION");
add_asm("");
add_asm(";Printnumber: imprime un número pasado por rax");
add_asm("number_to_string:");
add_asm("push 0                      ;Pusheo un 0 al stack para marcar el fin");
add_asm("mov rcx, digit_area         ;Pongo digitar area en rcx para guardar num");
add_asm("cmp rax, 0                  ;Veo si el número es menor a 0");
add_asm("jl .negativo                ;Si es negativo actúo de forma acorde");
add_asm(".loop:");
add_asm("mov rdx, 0                  ;Pongo rdx en 0 para dividir.");
add_asm("mov rbx, 10                 ;Voy a usar 10 para dividir");
add_asm("div rbx                     ;Divido rax por 10. Me queda en rdx el resto");
add_asm("add rdx, 48                 ;Le sumo '0' al resto");
add_asm("push rdx                    ;Pusheo a la pila la letra");
add_asm("cmp rax, 0                  ;Veo si rax es mayor a cero...");
add_asm("jne .loop                    ;...si todavía no es, loopeo.");
add_asm(".popear_todo:");
add_asm("pop rax");
add_asm("mov byte [rcx], al");
add_asm("inc rcx");
add_asm("cmp al, 0");
add_asm("je .listo");
add_asm("jmp .popear_todo");
add_asm(".listo:");
add_asm("ret");
add_asm(".negativo:");
add_asm("mov byte [rcx], '-'");
add_asm("inc rcx");
add_asm("imul rax, -1");
add_asm("jmp .loop");
add_asm("");
add_asm("copystring: ;Copia de rbx a rax un string. Toma largo de rax por rdx.");
add_asm(".loop:");
add_asm("cmp rdx, 0");
add_asm("je .ret");
add_asm("cmp byte [rbx], 0");
add_asm("je .ret");
add_asm("mov cl, [rbx]");
add_asm("mov [rax], cl");
add_asm("inc rbx");
add_asm("inc rax");
add_asm("dec rdx");
add_asm("jmp .loop");
add_asm(".ret:");
add_asm("ret");
add_asm("");
add_asm("strlen: ;String length counter (string = rsi, length = rdx)");
add_asm("push rsi");
add_asm("mov rdx, 0");
add_asm(".loop:");
add_asm("cmp byte [rsi], 0");
add_asm("je .ret");
add_asm("inc rdx");
add_asm("inc rsi");
add_asm("jmp .loop");
add_asm(".ret:");
add_asm("pop rsi");
add_asm("ret");
add_asm("");
add_asm("sleep: ;toma el tiempo a dormir en milisegundos por rax");
add_asm(";Paso de milisegundos a segundos y nanosegundos");
add_asm("mov rdx, 0");
add_asm("mov rbx, 1000");
add_asm("div rbx");
add_asm("mov rcx, rax ;Tengo en rcx la cantidad de segundos");
add_asm("imul rdx, 1000000 ;Paso el resto a nanosegundos");
add_asm("");
add_asm("mov dword [tv_sec], ecx ;Segundos");
add_asm("mov dword [tv_usec], edx ;Nanosegundos");
add_asm("mov eax, 162");
add_asm("mov ebx, timeval");
add_asm("mov ecx, 0");
add_asm("int 0x80");
add_asm("ret");
add_asm("");
add_asm("userinput:");
add_asm("mov rax, 3");
add_asm("mov rbx, 0");
add_asm("mov rcx, input_buffer");
add_asm("mov rdx, input_buffer_size");
add_asm("inc rdx");
add_asm("int 80h");
add_asm("mov rcx, input_buffer");
add_asm("add rcx, rax");
add_asm("dec rcx");
add_asm("mov byte [rcx], 0");
add_asm("ret");
add_asm("");